### Week 1

**class 1**

- 虚拟机有什么用？
  - 类加载
- GC 的作用是什么？
  - 内存管理
- 什么是运行时？
  - jvm运行java程序的环境
- 有虚拟机和垃圾回收为什么是优点？
- 真实内存是什么意思？
- 不用关心内存为什么性能不是最优？
- java对象指什么？
- 字节码文件和java源代码有什么关联？
- 类加载器如何加载字节码文件？
- 类加载器如何在内存中创建实例对象？
- 对象和内存有什么关系？
- 自定义类创建实例后的返回类型是什么？
  - Class<?>

**class 2**

- java字节码是什么？
  - bytecode
  - 由单字节指令组成
  - 最多只有256个操作码
  - 目前只用了200左右
- 字节码分四大类
- 操作系统基于栈和基于寄存器是什么？
- JVM基于栈
  - 关于栈的字节码与编程语言不对应
  - 与操作系统关联，保证程序运行的
- 类型转换指令是什么？
- javac 的作用是什么？
  - 编译
  - 获得class文件
- class文件是字节码文件
- javap的作用是什么？
  - 查看class文件的字节码
    - -verbose 可以打印常量池
    - 可以查看 jdk 版本
- JVM执行代码如何先存变量？
- 如何在栈上做计算？
- load指令加到栈上
- store指令存回变量表
- 偏移量是什么？
- 常量池是什么时候生成的？
  - 常量池和其他信息在编译完成后就确定了
  - JVM只需照着构建变量表、常量池、栈
  - 然后执行
- 常量池和操作码有什么关系？
- flags修饰符是什么？
  - public
- 栈的深度是什么？
- 操作码和操作数都存在字节码文件里么？
- 编译本地变量只给数量
- 编译时增加参数 -g
  - 增加额外信息
  - class会写入本地变量表
  - 不增加，反编译看不到本地变量名字
- 每个线程都有一个自己的线程栈
- 什么是线程？
- 栈帧是什么？
- 为什么每一次方法调用都要创建一个栈帧？
- Class 引用指什么？
- 本地变量表存储什么？
  - 相当于数据库
  - 操作数、操作结果、状态
- javap看到的是什么？
  - 操作指令和指令的集合
- 操作码和操作数
  - 操作码是字节码的解释
  - 操作码也是助记符，对应一个具体数字
  - 字节码是十六进制
  - java虚拟机把所有类型都转换成int
  - _下划线是为了压缩指令
  - 循环是用if/goto控制的
  - invokevirtual 
    - 调用方法
    - 调构造函数
  - 编译成字节码可以干掉语法糖
  - invokestatic 调用指令最快
  - invokedynamic
    - 调用动态方法
  - 什么是动态方法
    - 方法指针

**github**

- 版本控制是什么？
  - 管理代码的各个版本
  - 修改记录、复原
  
- 仓库是什么？
  - .git目录
  - 存放代码的地方
  - 配置用户名、邮箱
  
- track是什么？
  - git对文件的跟踪
  - 需要add
  
- working tree 是什么？
  - 正在进行的工作
  - 未提交
  
- 已修改状态
  
  - 文件处于工作区
  
- 已暂存
  - 暂存区
  - add 以后
  
- 已提交
  - comit 以后
  - 处于git仓库
  
- unstage是什么？

- github与git有什么关系？
  
  - github 开源项目发布平台
  
- https协议和ssh协议是什么？
  - ssh协议只需要第一次配置公私钥
  - https每次需要输入密码
  
- romote add的作用是什么？
  
  - 将本地仓库添加到远程
  
- push的作用是什么？
  
  - 把本地文件推送到远程仓库
  
- 公钥和私钥的作用是什么？
  - 用于本地和远程github建立连接
  - 公钥配置到平台
  - 公钥用于加密密码
  - 私钥用于解密密码
  - 二者成对出现，相互对应
  - 公钥相当于一个带锁的盒子，用于存放密码
  - 私钥相当于盒子的钥匙
  
- ssh如何连接？
  - 计算机之间加密登录
  - 利用公钥和私钥
  
- git branch -m 是什么

  - 修改分支名字

- error: src refspec main does not match any

- token: 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

- ```
  远程上传
  git remote add origin git@github.com:ratheroo/JavaClass.git
  git branch -M main
  git push -u origin main
  ```

**class3**

- 如何动态加载jar包？
- 类有抛出异常如何排查？
- 类的生命周期是什么？
  - 类加载、使用、卸载
- 类加载时如何验证依赖？
- 初始化中的构造器是什么？
- 什么时候加载类？
  - 显示调用
  - 隐式调用
- 显示调用是什么？
  - java命令启动时，主类
  - new指令
  - 调用静态方法和静态字段
- 什么是静态方法、字段？
- 隐式调用是什么？
  - 初始化子类，加载父类
  - 初始化实现类，加载接口定义的defaultf方法所在的类
  - 反射调用某个类
  - 初次调用MethodHandle
- MethodHandle是什么？
  - 方法指针
- 还没用到，不会初始化
  - 调用常量是从常量池调用
  - loadClass加载了，但没初始化
- rt.jar是什么包？
- 为什么有三种类加载器？
- lab目录的jar包会自动加载么？
- 父加载器委托是什么？
  - 父类加载过的不再加载
- 负责依赖是什么？
  - 当前类加载器负责依赖类的加载
- 缓存加载是什么？
  - 类被加载后会缓存到内存里
  - 不会重复加载
- 自定义类加载器有什么用？
  - 类的动态加载
  - 加密保护代码
- 如何看当前程序加载了那些jar包？
- open JDK 和 Oracle jdk 是什么？
- 拿到类加载器有什么用？
- ucp 字段是什么？
- 加载文件夹是什么意思？
  - 文件夹下面的classs
- 默认jar包可以丢到扩展类加载器里面
- 什么是Base64编码?
  - class文件转换Base64编码字符串
- 加载后初始化的作用是什么？
- 加密后的文件怎么转换成字节码？
- -Djava.ext.dirs 添加扩展路径
- java -cp/classpass 引用
- addUrl方法添加路径

**class4**

- 线程是什么？
- 原生类型的局部变量是什么？
  - int/long/float
- 堆内存存的什么？
  - java 对象
- 线程如何把对象存储在堆内存上？
- java 对象和引用类型有什么关系？
- 静态变量为什么也是一个对象？
- 堆和栈有什么区别？
- JNI方法是什么？
- 调用方法为什么要创建栈帧？
  - 大小编译后确定
  - 逻辑概念
  - 结构同 javap 字节码结构
- GC 算法是什么？
  - 控制对象在堆内存上的创建和销毁
- 分带GC是什么？
  - 分带假设是什么？
  - 分带算法的特点是什么？
- 年轻代和老年代有什么区别？
- 非堆内存存什么？
  - 不是代码里创建的对象
  - JVM运行时候使用的数据
  - 类在JVM层面描述的元数据
- 什么是K-Last?
- JIT是什么？
  - 动态的即时编译
- 动态即时编译在什么时候使用？
- 开启压缩对象指针是什么？
  - 压缩内存地址
  - 节省空间
- 为什么把元数据区划到非堆里？
- 健康锁是什么？
- jvm自身包含什么？
- JMM如何保证不同的JVM实现效果一致？
- JMM是什么？
  - 规定怎么用线程之间共享的数据
  - 多线程访问冲突时的方案
  - 线程之间的交互的方案
- 同步操作是什么？
- volatile 变量是什么？
- 管程是什么？
- 线程的起始操作和结尾操作是什么？
- 线程的起始和结束需要启动什么？
- 外部操作是什么？
  - 对其它线程的操作
  - 与本线程无关的操作
- JMM如何解决线程之间交互产生的问题？
- 线程之间互操作会产生哪些问题？
- 规范是跨平台的关键



**class5**

- VM potions 和 program arguments 有什么区别？
  - 等价
- -标准参数
- -D系统属性
- -X非标准参数
- 非标准参数是什么？
  - 不保证所有JVM都支持
  - java -x 查看
- -XX 非稳定参数
  - 随时可能取消
- 运行模式参数是什么？
  - 指定运行场景
- 分析诊断参数是什么？
  - 内存快照
  - 用工具分析
- 程序中可以获取环境变量
- -Xint/-Xcom/-Xmixed
  - 指定如何缓存编译后的字节码
- -Xmx指定最大堆内存有什么用？
- -Xms初始化大小有什么用？
- 什么是full gc抖动？
- xmx/xms如何配置？
- -xmn 升值young区大小有什么影响？
- young区的作用是什么?
- 堆外内存存储什么？
- 为何要允许设置各类内存？
- 线程栈的内存不够会如何？
  - 栈内存溢出
- 默认配置为何与GC算法有关？
- Saas系统是什么？
- 配置的内存超出了会如何？
- 混合部署是什么？
- 逗号化是什么？
- 不同GC算法有啥区别？
- gdb是什么？
- -xdebug 调试的是什么代码？
  - 远程到ide调试
- javaAgent 是什么？
  - 拉agent库
  - 对所有加载的类进行预处理
- agent对类的预处理有什么用？
  - 无侵入对现有程序功能加强
  - 例：cpu使用时间抽样分析
- 对类的增强指什么？
  - 增加程序的功能



**class6**

- jvm运行情况都指什么？
  - 内存、线程指标
  - 对象的情况 
- GC策略是什么?
  - 内存管理算法
- 内存管理算法都针对什么问题？
- GC的运行情况指什么？
- 每一个java命令都启动一个虚拟机么？
- 启动多个虚拟机之间是否有影响？
- javap 反编译class后的成果是什么？
  - 使用注记符标识的字节码
  - 类的大致结构
- jni开发是什么？
  - java里调用其它平台或语言
- java里调用其它平台指什么？
- java代码都可以生成.h文件？
- keytool怎么控制程序安全？
- jarsigner的签名和验证方式有什么用？
  - 标识jar包没被改过
  - 相当于撕毁无效？
- 本机java安全策略包括什么？
- java 安全沙箱有什么用？
- 整合命令是什么？
  - 可以跟参数执行不同命令
- sudo 命令是什么？
- gc 什么情况产生？
- jps命令的作用是什么？
- gc 的情况对程序有何影响？
- -gc/gcutil 显示的字节数和百分比指什么？
  - 使用的空间
- 堆每个区使用的大小对程序运行有什么影响？
- gc 次数能说明什么？
- 分析JVM情况看哪些指标？
- jmap -histo 打印出来的是什么所占的空间？
  - 类和实例
  - 各种类型的对象
- dump是什么？
- 堆内存的转储文件的内容是什么？
- 为什么两个s区总有一个是空的？
- 长列表模式是什么？
- 线程相关的锁有什么用？
- thread dump 是什么？
- js的java引擎指什么？
  - 在java中运行js代码？
- shell是什么？
- curl命令是什么？
- jjs相当于js控制台
- nexus 是什么？
- spring boot 项目自定义的入口如何定义？
- 静态方法是什么？



**class7**

- jmx协议是什么？
  - 访问jvm进程？
- 线程峰值是什么？
- 线程中的死锁是什么？
  - 两个线程想要对方持有的锁
- 锁是什么？
- 进程占用CPU时间指什么？
- 热点的方法和热点的代码是什么？
  - 运行特别频繁的代码和方法
- sample时间段内统计方法类
- 飞行记录是什么？
  - 未来时间段，jvm状态变化的记录
- GC时间是什么？
- jevn怎么使用？

**class8**

- GC算法复杂在哪里？
- 实际情况复杂的地方出现在哪里？
  - 为何形成环的仓库无法被回收
- 引用跟踪与引用计数区别在哪里？
  - 引用跟踪按是否可达清除对象
  - 无循环依赖问题
- 根对象是什么？
  - 当前方法的局部变量和输入参数
  - 活动线程本身
  - 静态字段（全局有效）
  - JNI
- 活动线程本身是什么？
- JNI是什么？
- 怎么判断哪些是不可达对象？
- 如何找出不可达对象？
- 不同GC算法区别在哪里
- 如何判断不同对象存活的时间，将其归代？
  - 对象由年轻代进入老年代
  - eden满3次：eden->s0->s1->s0
- 如何由年轻代进入老年代？
  - 存活周期
  - 老年待阈值
  - 经过多次GC依然存活
- 老年代何时GC？



**class9-11**

- 串行GC是什么？
  - 可以配置
  - 年轻代 Mark-copy
  - 老年代mark-sweep-compact
- 串行GC有什么局限？
  - 无法并行处理
  - 处理每个区都会STW
- GC如何并行？
  - 可配置 -XX
  - 多个线程处理垃圾
- 多个线程如何处理垃圾？
  - 与CPU核心数相等的线程
- 为何并行回收需要多核？
  - 每个CPU只能启动一个线程处理？
- 多核之间如何区分谁处理哪部分垃圾？
- 吞吐量和GC线程时间是什么关系？
  - GC需要时间不变
  - 吞吐量代表需要GC的频率
- 业务处理吞吐量指示什么？
  - 处理业务的量
  - 业务量化为读写数据量
- G1是什么?
- ParNewGC有何改进？
  - 年轻代并行回收
- 跟踪GC执行跟踪哪些参数？
- 内存变化如何分析？
- 并行设计需要注意什么？
- CMS 是什么？
  - Mostly Concurrent Mark and Sweep
  - Concurrent 是什么？
    - 并发
- CMS 与并行的区别是什么？
  - 使用空间表去掉压缩过程
  - 没有STW
- free-lists为什么可以替代压缩？
- CMS 为什么可以没有STW?
  - 每次只清理部分线程
  - 部分线程暂时停止
- 有不造成STW的GC算法么？
- CMS造成的GC暂停时间相对较短么？
- 并发是什么？
  - 一起发生
- 并发和并行有什么区别？
- 不直接暂停所有业务线程为什么叫并发？
- 并行并发和线程有什么关系？
- 并发前置条件是什么？
- 如何标记对象？
- 年轻代指向老年代的对象是什么？
  - REMEMBER SET中的记录跨带引用对象	
- 标记状态不精确怎么处理？
- 预清理如何识别脏对象？
- CMS 最终标记后，对象引用关系仍然变化，如何清除？
- CMS 重置哪些状态？
- 内存不连续会造成什么问题？
- CMS 为何会受堆内存大小影响？
- CMS young 区堆内存大小只受线程数影响么？(jdk 8)
- G1 GC 改进了哪里？
  - 认为设置STW时间
- G1 GC 提出的背景问题是什么？
- 吞吐量和延迟有什么关系？
  - 吞吐量越大，延迟越长
- 什么是启发式？
  - 逐渐调整
- young 区的作用是什么？
- 一个对象一般不超过多大？
- 什么是停止回收堆内存大小？
  - 堆内存占用量低时，不回收垃圾
- CPU资源以时间计算么？
- G1 GC 为什么会退化成 串行 GC?
- 老年代填满为何会造成退化？
- 退化指什么？
- *full gc 为何会导致内存退化？*

**class12**

- ZGC 改进了什么？
  - 降低延迟
- ZGC 为何可以把 stw 控制在 10ms 以内？
- rt是什么？
- Shennandoah 改进了什么？
- 着色指针和读屏障是什么？
- GC 吞吐量影响什么？
  - 系统能处理多少业务
- 延迟影响系统什么？
  - 业务处理的速度
- 收集器是什么？

### Week 2

**class1**

- GC日志记录什么？
  - 打印 -XX:+PrintGCDetails
  - 堆内存情况：GC发生原因，GC暂停时间，young区大小变化，堆内存大小变化
  - CPU情况
- GC调优与JVM整体调优有什么关系？
- while循环内部的对象结束会被GC一次么？
- old GC 和 full GC 有什么关系？
  - full gc 为 young gc + old gc
  - young gc 很快
  - old gc 执行比较长
- full gc 什么时候发生？
- GC日志在哪？
- 堆内存大小和GC频率的关系是什么？
  - 容量变大
  - gc次数变小
- 堆内存溢出是因为GC跟不上了么？
  - GC频繁
  - gc回收不掉的内存大于堆内存

- 不同GC策略影响哪些性能
  - GC次数
- CPU使用是串行的么？
  - CPU使用时间加在一起是程序运行总时间么？

- 怎么判断自己程序需要的大概堆内存？
  - 什么样的GC频率是合理的？
- gc执行效率低是什么意思？
  - 执行时间长
  - 执行次数多
- 自适应参数是什么？
  - 各种参数动态变化 old gc 阈值，young区大小等
- 什么影响GC暂停时间？
  - 内存大小
- -xmx/-xms 不一致为什么full gc增加？
  - jvm需要逐步增加到xmx，中间产生多次gc
- cms过程中为何会发生多次young GC？
- CMS初始化标记和最终标记有什么区别？
- CMS GC循环是什么？
- G1 GC 如何模拟 full gc?
- G1 gc 退化是什么？
  - 如何防止退化？
- GC日志解读软件
  - GCEasy
  - GCViewer
- GC暂停时间多少合理如何分析？
  - 总体业务时间可接受



**class 2**

- 线程堆栈角度能分析出哪些信息？
- JVM线程模型是什么？
- JAVA线程和操作系统线程有什么关系？
- 操作系统线程是什么？
- 真实的物理线程是什么？
- java层面和jvm层面有什么不同？
- 自定义线程是什么？
- jvm需要启动的线程都有什么作用？
- 什么是单例？
- JIT是什么？
  - 编译器线程
  - 字节码编译成本地代码
- 安全点是什么？
  - jvm 插入
  - 做检查的点
- 检查点的临界区是什么？
- 线程如何能继续之前的活？
- 线程需要的信息如何保存，如何寻找？
- jvm线程的状态看哪些参数？
- MBean是什么？
- 线程死锁是什么？
- dump是什么？
  - 转存、导出 
- 为什么1000个对象内存占用更大？
  - 每个对象也占空间
- 为什么要设计成头和体？
- 机器字是什么？
- 标记字、Class指针、数组长度是什么？
- 什么是数据宽度？
- 为什么以32位或者64位为整？
- 实际使用内存的最小操作单位由什么确定？
- 对齐为什么分内部对齐和外部对齐？
- JOL可以查看对象的内存布局
- Integer为何比int占用更多字节？
- 对象指针压缩只能压缩部分么？
- 内存泄漏是什么？
  - 内存回收不掉
  - 能用的减少
- 堆内存溢出是什么？
  - 没有内存可用
  - 需要放的东西放不下，溢出
- hashcode方法的作用是什么？
- 线程是什么？
  - 某项工作
- jvm信号分发线程是一直运行么？
- 线程池是什么？
- 堆内存都存什么？
- 什么情况下创建线程无意义？



**class3**

- 判断未来是否会崩溃的原理是什么？
- 分配速率和提升速率为什么能指示是否崩溃？
- 分配速率是什么？
  - 单位时间给新对象分配的内存量
  - 速率太高会导致GC占用资源太多
  - 最好和垃圾回收速率平衡
- 分配速率是否需要与垃圾回收速率相等？
- 速率太高的持平有什么危害？
- young 区一般是整个堆的1/3
- 蓄水池效应
  - 频率高或者吞吐量大
- 提升速率是什么？
  - 老年代的分配速率
- 老年代的回收算法哪些特点是针对长期存在的对象？
- 为何频繁回收会影响老年代的GC效率？
- old 区满了会导致 full gc
- 网络情况如何影像性能？

**class4**

- apm 分析软件是什么
  - 应用性能监控
  - application peformance monitor
- 调用栈分析什么？
  - 挑出慢的，优化
- 阿尔萨斯开源
- 线上问题怎么排查？
- 分析问题需要收集什么指标？
- 指标的关联性指什么？
- 什么是80/20原则？
- 系统资源使用情况包括什么？
  - cpu 负载
  - 内存
  - 磁盘使用量
  - 硬件
  - 网络
    - 流量、丢包、dns、防火墙、长连接是否超时、短连接数量
- 部署架构情况包括什么？
- 网络抖动是什么？
- 短连接是什么？
- TPS是什么？
- 中间件的性能如何查看？
- 系统外部环境指什么？
- 性能压测如何模拟？
  - 直接输参数测
- CPU使用率能说明系统处于什么状态？
- 负载和使用率有什么区别？
- k8s是什么？



**class5**

- nio是什么？
- io请求是什么？
- socket编程是什么？
- io模型模拟什么？
- 什么是网络编程？
- 网卡的作用是什么？
- 端口号范围如何计算？
  - 0-65535
- 默认服务的端口有哪些？
  - http 80 https 443  ftp 21 收发邮件 25/110
- 默认端口是系统功能么？
-  连接以后，双方可以互相发送数据（双向通信）
- 压测是什么？
- 压测如何得到每秒的请求数？
- 线程为何是资源？
- 为何要复用线程？
  - 创建线程消耗资源
- 创建线程使用哪些资源？
  - 内存、cpu
- 线程为何可以被复用？

**class6**

- CPU 密集型操作是什么？
- IO密集型操作和CPU密集型操作有什么关系？
- 多线程改善网络通信效率的原理是什么？
  - 提高 CPU 使用率
  - 增加吞吐量
- CPU资源空耗指什么？
  - cpu 没有工作，空等待
- 一个线程相当于一个工人
- io 等待时间是什么？
- linux 内存分为用户空间和内核空间
- 不能拆分的计算和io包括哪些？
- 流水线化的处理是什么？

**class7**

- 同步、异步指什么？
  - 通信
- 阻塞、非阻塞形容什么？
  - 线程
- 通信指什么？
  - 与其他对象交流
- 线程空转是什么？
  - 线程暂停了
- 什么情况下会阻塞？
- 阻塞IO与非阻塞IO分别指什么？
  - 非阻塞IO复制之前可以继续做其他事情
  - 非阻塞复制时依然阻塞
  - 非阻塞是轮询内核
- 线程是被谁阻塞的？
  - 另一个线程
- io 多路复用改进了什么？
  - 单独起一个线程做轮询工作
- 非阻塞IO一杆子捅到底不合理在哪？
- io 多路复用为什么能提高效率？
  - 按需起工作线程
  - 必要时才起
- 文件描述符是什么？
- 调用select 时为什么需要拷贝 fd?
- 用户线程如何与reactor交互？
- select/poll/epol 的作用是什么？
- 线程不用阻塞，在哪方面灵活？
- 事件机制是什么？
  - 发生了以后再做出反应
- 如何拆分eda模块？
- SEDA中的S指什么？

**class8**

- 什么是网络应用编程？
- 微服务是什么？
- spring 网关是什么？
- netty 的事件模型是什么？
- 协议支持是什么？
- netty 为什么需要数据序列化和反序列化？
- 不同的序列化方式有什么特点？
  - 压缩
- netty 的零拷贝技术需要系统支持么？
- netty 实现扩容需要系统支持么？
- 网络处理指什么？
- 网络和业务如何分离？
- netty 如何自定义协议？
- websocket 协议规定什么？
  - 服务端与客户端信息交流
  - 用于服务端给客户端推消息
- j2ee的能力指什么？
- 容器上的事务指什么？
- JMS消息是什么？
- 命名服务是什么？
- EJB是什么？
- handler 是事件处理器
- channel pipeline 在哪里使用？
- 事件的处理逻辑指什么？
  - netty 处理出站、入站等事件
  - 与 io 相关的事件
- 适配器是什么？
- pipeline中直接添加编码器、聚合器、handler的作用是什么？
  - 启用顺序是什么？



### Week3

**class1**

- 高性能是什么？
  - 高并发用户
  - 高吞吐量
  - 低延迟
  - 容量
    - 容量指什么？
      - 系统各方面承受的量
- 事务数是什么？
  - 处理事务的数量
- QPS是什么？
  - 每秒请求处理数
- netty 调优调节什么？
- api 网关是什么？
- 微服务是什么？
- 高性能系统复杂在哪里？
- 混沌工程指什么？
- 爆炸半径是什么？
  - 问题影响的范围
- 跟因分析

**class2**

- selector 是什么？
- 事件处理使线程不用io等待？
- 事件机制是什么？
  - 一件事发生
- 多路复用是什么？
- serviceHandler 的作用是什么？
  - 派发事件
- reactor不同模型的区别是什么？
  - 单线程只有一个reactor线程处理所有事务
  - 多线程，reactor处理io部分，业务处理由线程池处理
  - 主从模型，io 部分拆分成主从：socket连结、事件分发
- 业务和io隔离
- 网络 server 包括哪几种类型？
- EventLoop 是什么？
  - io事件的循环
  - 带selector线程
- selector 为什么能跟channel 通信？
- 一个eventLoop为什么可以绑定多个channel？
  - 一个channel相当于一个传送带
- handler集合如何与channel绑定？
  - channel 初始化时绑定
- boosGroup 做什么工作？
- 出站入站为何挂多个handler?



**class3**

- 网络程序有哪些可以优化的点？
- tcp协议是什么？
- 粘包和拆包是什么？
  - 两个包粘成一个
  - 一个包被拆了
- 回车和换行符有什么区别？
- 如何同时避免网络拥堵和发包延迟？
- 缓冲区的作用是什么？
  - 收件点
- tcp_nodelay 如何开启？
- 链路层是什么？
- 网络最大传输单元受什么限制？
- tcp头和ip头的内容是什么？
- 最大分段大小是什么？
  - 最大能发送的数据大小
  - 1460字节（1500）
- 报文拆分由哪里控制？
- 三次握手的作用是什么？
  - syn 什么含义？
    - 你在么
  - ack 什么含义？
    - 我在 
- 四次挥手的作用是什么？
  - FIN 什么含义？
    - 结束
  - ack = 1 表示确认
- 客户端为什么需要等待两个时钟周期才关闭？
  - msl 是什么？
    - win 2min / linux 1min
- 重新利用未关闭的连接做什么？
  - 不用重新创建连结
- 为何挥手不能三次？
- udp 广播式协议
- 网络应用程序优化哪些点？
- 链接的文件描述符作用是什么？
- backlog是什么？
  - 半链接状态的链接数
- reuseXXX 的作用是什么？
- 心跳机制的作用是什么？
  - 查看服务器是否正常
- byteBuffer是什么？
  - 内存缓冲区
- ioratio 处理io 消耗cpu 与业务消耗 cpu 比例
- 高、低水位指什么？
- 流控有什么用？
  - 先缓存，再慢慢读
  - 保护系统

**class4**

- api 网关是什么？
  - 内部服务接口的网关
- 业务聚合是什么？
  - 整合所有接口
- 流量网关是什么?
  - 与业务无关
  - 系统安全
- 为什么需要业务网关？
  - 服务级别流控
  - 单个服务的保护
  - 不同级别的用户权限控制
- nginx 的作用是什么？
- 流量网关和nginx的关系是什么？
- 业务网关部署在哪里？
- 服务的发现指什么？
- 微服务体系是什么？
- 微服务框架包括什么？
- 内部服务指什么？
- 中间层和服务如何关联？
- 流控包括什么？
- sql 注入是什么？
- pre filters/ router filters/ post filters的作用分别是什么？
- http server 的作用是什么？
- netty 的地位是什么？
- lua 是什么？
- lua 脚本如何使 nginx 有变成能力？
- spring web 是什么？
- spring cloud gateway 如何与spring整合？



**class5**

- http server 的作用是什么？
  - 接收用户请求
  - 返回结果数据
- 对请求增强是什么？
- 服务和实例的关系是什么？
- 路由如何决定调用哪个实例？
- 路由之前是否判断服务是否正常？
- inbound handler 为什么把读取数据交给 outbound handler?
- 技术和业务的复杂度指什么？



**class6**

- order by now
- 并发编程要注意什么？
- 分布式与并发有什么区别？
- 摩尔定律是什么？
  - 瞎观察得出的蠢结论
- 操作系统管理系统资源
- 进程是加在哪两层中间？
- 为何内存会被抢占？
  - 多个cpu使用同一个内存
- 锁如何锁住指定资源？
- cpu内核架构指什么？
  - cpu 与内存的关系
  - SMP 多个 cpu 共享同一块内存，争抢一块内存
  -  NUMA 把cpu与内存分组
- 为何会有数据跨cpu内存分组？
- start会创建一个操作系统的线程
- 直接调用run不创建线程
- 进程之间使用的内存一般隔离

**class7**

- 为何要用runanble 包装 run 方法？
  - 线程和任务拆分
- 线程的名字作用是什么？
  - 诊断分析
- 什么是守护线程？
- 为什么jvm会终止守护线程？
- jvm主线程执行完检查子线程
- lamdba 操作是什么？
- 显示和隐式怎么理解？
-  runnable状态是什么？
  - 等待cpu时间片段
- 如何将线程改成non-runnable？
  - notify
- join能得到其它线程的返回结果么？
  - 不会
  - 本质与wait一样
- wait 和 sleep 有什么区别？
  - wait可以没有时间
  - wait可以被notify唤醒
  - wait会释放锁，sleep不会
  - wait唤醒时会重新获取锁
- 线程的锁是什么？
- wait 是object 对象方法
- notify是按照对象唤醒
- 多个对象唤醒用notifyall
- wait notify 机制针对什么场景？
- yield的使用场景是什么？
- obj对象锁是什么？
- 对象锁和线程锁有什么关系？
- future可以封装线程，获得线程产生的结果
- interrupt 打断暂停状态后发生什么？
  - 抛出异常
- interrupt的应用场景是什么？
  - 通过外部变量控制，产生sleep等中断
  - 给外部interrupt机会
- 为什么要通过interrupt控制线程终止？
- interrupt异常在内部
- 外部全局变量如何终止线程？
- 临界代码块指什么？
- 线程哪些情况下会被blocked?
- 同步块是什么？
- 增强锁是什么？



**class8**

- 线程安全指什么？
  - 不同线程修改变量
  - 其它线程不知道
- 线程安全问题是什么？
  - 对同一资源先后操作
  - 导致不同线程获取的资源不一致
- 竞态条件是什么？
  - 多个线程使用同一资源
  - 资源对操作顺序敏感
- 临界区是什么？
  - 操作共享资源的代码
- 多线程的框架有哪些？
- 如何解决并发安全问题？
- 原子性是什么？
  - 操作过程中无法被插入其他操作
- 可见性是什么？
  - 操作能被其它线程看到
- volatile 变量是什么？
  - 读写立即更新到主内存
- 副本如何同步到主内存？
- synchronized 同步块的作用是什么？
  - 操作可见
  - 每个线程执行完，下一个执行
  - 类似单线程
- 隔离级别指什么？
- 独立提交是什么？
- 可重复读是指什么？
- 有序性是什么?
  - 锚点放在那里？
  - 八条规则是由谁来确保的？
- 偏向锁、轻量级锁、重量级锁之间有什么区别？
  - 偏向锁是用第一把锁锁住被锁对象
  - CAS是什么？
  - 重量级锁是什么？
- 标记锁为何要用某种数据结构？
- 锁对象指向的数据结构是什么？
- 增强锁是什么？
  - 给一个对象加多把锁
- synchronized的参数的作用是什么？
  - 被锁的对象
- 锁分离是什么？
  - 创建不同锁对象
  - 相当于多把锁
- 并发的数据结构是什么？
- volatile 如何保证有序性？
- 为何会发生指令重排？
- static的作用是什么？
- 常量有何作用？



**class9**

- 线程池的作用是什么？
  - 线程复用
- 上下文切换指什么？
- 线程池如何处理大量并发任务
- ThreadFactory 的作用是什么?
  - 相同配置
- 不同类型的线程池有什么区别？
- submit方法的作用是什么？
  - 有返回值
- 哪些异常不能被submit接住？
  - 算数型异常
- future是什么类型？
- 如何给线程传递新任务？
  - execute
- 优雅停机是什么？
  - 正在之心的业务执行完再停
- 工作队列的作用是什么？
  - 放置等待的任务
- 拒绝之后代码会报错么？
- 缓冲队列何时被取出？
- linked list 是什么？
  - 一个接一个的链表
  - 长度不固定
- 操作 blockingqueue 的两个线程是线程池创建的么？
- 派发任务的线程如何执行任务？
- 计算密集型为何没有线程等待？
  - 中间没有io等待
- 线程等待是什么？
  - 没有使用cpu资源
- 线程等待期间为何有资源执行更多的任务？
  - cpu空闲
- cpu的作用是什么？
- callable 有什么特点？
- future 时间参数作用时什么？
  - 超时时长
- 泛型是什么？
  - 不固定的类型





**week4**

- 原子类是什么？
- 并发工具类都能做什么？
- 集合类型是什么？
- 多线程之间都有哪些协作？
- javax是扩展
- j2ee标准是什么？
- lang什么意思？
- rpc远程调用是什么？
- jdbc是什么？

*java 并发工具包*

- 并发编程问题为何分五大类？
- 并发编程与多线程有什么关系？
- 多线程有哪些问题？
  - 锁的控制有哪些问题？
  - 锁重指什么？
    - 锁住以后只能串行执行
  - 原子类主要解决计数问题么？
  - 线程间如何相互协调？
  - 集合类线程不安全指什么？

*锁*

- 什么是锁？
  - 占用标记
- wait/notify为什么可以看作加锁和解锁？
- 显式锁是什么？
- 如何尝试拿锁？
- 如何根据条件加锁？
- 公平锁是什么？
  - 排队最久的优先拿锁
  - 随机给锁是非公平锁
- 可重入锁是什么？
  - 同一线程是否可以重复使用同一锁
- 持有锁的是什么？
  - 线程
- 锁的对象是什么？
  - 内存？
- 共享锁与不锁有什么区别？
  - 共享锁上只能再加共享锁，不能加排他锁
- 拿到锁对象能进行哪些操作？
- final对象内为什么会有可以改变的字段？

*并发原子类*

- 计数器如何能不串行化计数？
- 原子类是数据类型
- 原子类线程安全的原理是什么？
  - compareAndSwap 是什么？
    - CAS 
    - cpu硬件指令支持
    - 塞回去的时候发现值变了，重新操作
  - 乐观锁是什么？
    - 假设不用锁
  - cas指令自旋不也相当于单线程么？
    - 节省一些加锁解锁操作
  - native 修饰是什么？
    - 在jvm层实现
- longadder如何将多线程计数改成单线程计数？
  - 分段，然后相加
  - 不用抢同一个资源

*并发工具类*

- 并发工具类是做什么的？
  - 进行并发控制的模板
- 多个线程协作需要哪些信息？
- 多线程需要控制哪些方面？
  - 控制某资源并发数量
  - 控制多个线程同时运行
  - 指定数量线程达到某个状态继续进行
- 业务代码如何与多线程代码分离？
- aqs是什么？
  - abstract queued synchronizer
  - 队列同步器
  - 最核心的基础组件
  - 控制线程队列与竞争资源
- 资源为何可以看作state?
- samaphore 信号量的作用是什么？
  - 控制并发数量
- 并发工具为何可以控制并发数量？
  - 只能控制读锁？
- countDownlatch 工具作用是什么？
  - 控制多个线程达到某种状态	
- cyclicBarrier 工具做什么？
  - 循环 屏障
  - 控制多线程同时运行
  - 可复用
- completeablefuture 与 future/futuretask 有什么区别？
  - 异步获取结果
  - 回调
  - 异常
- future.get 为何是异步转同步？
- 如何通过回调获得异步线程结果？



*线程安全类型*

- 线程安全类型是什么？
- 线性数据结构是什么？
  - 排成一条线的数据
- 线性数据都基于collection类
- properties中是字符串key/value

*arraylist*

- arraylist 数组实现的 list
- arraylist 如何扩容？
  - 复制老数组
- transient 前缀是什么？
  - 不序列化
- arraylist 写冲突、读写冲突

*linkedlist*

- 并发修改异常如何判断的？
- list的如何线程安全操作？
  - vector
  - Collections.synchronizedList
  - Arrays.asList 不允许添加删除元素，只能改
  - Collections.unmodifiableList，不允许修改
- 加锁加哪里？
  - 实例对象头
- 快照解决什么问题？
- CopyOnWriteArrayList有什么特点？
  - 写加锁
  - 读当前时间点快照
- CopyOnWriteArrayList解决什么问题？
  - 读写比高
  - 读并发执行
  - 写在副本
- CopyOnWriteArrayList迭代时修改数组怎么处理？
  - 可能不支持迭代修改

*hashmap*

- 取模方式如何压缩？
- hashmap不能用于并行么？
- linkedhashmap如何获取插入顺序？
- linkedhashmap访问顺序有什么用？
- stream编程是什么？
- concurrenthashmap改进了什么？
  - 分段-16
  - 锁段
  - 要求数据尽量能分散到每段
- jdk8 去掉分段如何解决并发？
  - 乐观锁
- jdk8如何用乐观锁解决并发问题？


*java 并发编程*

- thread local 处理哪类问题？
  - 线程本地变量
- 线程操作对象如何只针对本线程有效？
- 线程本地变量针对何种场景？
  - 同一个方法栈
  - 外层设置参数，里面取参数
  - 不用显式传参 
- context 模式是什么？
- 池化模式是什么？
- stream并发执行是指执行什么？
- stream是什么？
- 伪并发冲突何时发生？
- 服务器端如何做防重复提交？
- 同一个jvm里多线程可以共享哪些信息？
- 分布式环境如何处理并发冲突？
- 并发何并行有何区别？
- 如何控制全局流量？
- 分布式缓存缓存在哪里？



*经验*

- 如何理解原地自旋？
- 对象在堆上，线程何堆独立
- 线程可以共享堆上数据
- 线程间合作的需求有哪些？合作的方式有哪些？
- 进程间如何协作？
  - 缓存？


