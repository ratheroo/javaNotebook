*为何要做数据库的拆分*

- 节点数据量过大为何会影响主从同步？
- 如何解决数据库性能和容量问题？
- 拆分数据库的原则是什么？
- 数据库容量大为何无法备份？
- 分库为何会导致一致性被破坏？
- 一致性破坏指什么？
- 系统扩展指什么？
- 数据分片是什么？
  - 根据什么拆分同类数据？
  - 根据数据特征拆分
- 分布式服务化是什么？



*数据库垂直拆分*

- 分布式服务化是什么？
- 微服务是什么？
- rpc框架是什么？
- 数据中间件是什么？
- 防腐层和adapt层的作用是什么？



*水平拆分*

- partition 分文件存储有什么作用？
- 单纯分表无法降低磁盘io和网络io
- 数据迁移会带来什么问题？
- 强一致是什么？
- INLINE 是什么？
- 预取是什么？
- 线上资源是什么？



*数据库框架*

- java框架层面和中间件层面区别在哪？
  - 业务侧
  - 数据库侧
- 分布式环境面对的问题CAP分别指什么？
  - C 一致性
  - A 可用性
  - P 分区容忍性
- 分区容忍性指什么？
- 一致性指什么？
- 数据库网格是什么？
  - 服务网格是什么？
  - 数据面板是什么？
  - 控制面板是什么？
  - sidecar 是什么？
- ShardingSphere-Proxy 独立部署
- 分布式数据库和数据库网格的区别是什么？



*数据迁移*

- 数据迁移要注意哪些问题？
- 快速，准确
- 全量加增量如何更新？
  - 时间戳的作用是什么？
  - 增量迁移之前的迁移不需要停机么？
- binlog方式如何做迁移？
  - 使用中间件模拟从库
- 断点续传是什么？
- 自动扩容缩容如何实现？
- 进度位置如何记录？
- shardingsphere-scaling



*XA分布式事务*

- xa_recover作用是什么？
  - 拿出准备好的xa事务
- 二阶段的作用是什么？
- 什么是活动序列图？
- 提交事异常则发送回滚
- xa_end 事务的作用是什么？
  - 通知sql执行完了
- 回滚时崩溃如何处理？
- xa框架如何使用？
- 隔离级别是什么？
- 数据视图是什么？



*BASE 柔性事务*

- 刚性事务是什么?
- BASE
  - Basically Available
  - Soft state
  - Eventually consistent
- 保障最终一致性的机制有什么？
- 柔性事务需要新增什么接口？
- 并发高低是什么？
- TCC与AT差异是什么？
  - tcc 手动补偿
  - at 自动补充
- 补偿的作用是什么？
  - 反向操作，相当于回滚
- 和 AQS ——》同步锁 比的相似性在哪里？



*TCC/SAGA/AT*

- TCC 是什么？
  - 业务侧模拟XA事务阶段
  - 两阶段 try confirm/cancel
- AT 是什么？
- 什么是空回滚？
  - 能检测到空回滚的情况并进行空回滚
- 防悬挂是什么？
  - 调用方超时，发送cancle请求，空回滚
  - try 后收到消息，try 操作应该被拒绝

- 幂等设计是什么？
  - 幂等是什么？
  - 多次操作结果与一次操作结果是一致的
- SAGA是什么？
  - 提前写好撤销方法，发生错误时依次执行
- AT是什么？
  - 中间件，拦截sql，自动生成反向sql
- 隔离级别是什么?
  - 全局锁 读已提交
  - 无全局锁 读未提交
- SPI 是什么？
- shardingsphere 如何支持分布式事务集成？
  - 对分布式事务做抽象
  - 支持 seata 柔性事务
- shardingsphere 如何开箱即用？



### 分布式服务模块

*RPC 基本原理*

- RPC相关的技术有什么？

- RPC 是什么？
  - Remote Produce Call
  - Produce 是什么？
  - 调用本地方法一样调用远程方法
- stub 是什么？
  - 本地调用远程的代理
  - 存根
  - 实现原理是什么？
- 调用远程方法相对于调本地方法有哪些限制？

- 分布式解决什么问题？

*RPC 技术框架*

- 如何设计RPC框架？
- mq技术是什么？
- rpc原理是什么？
  - .create 生成 stub
  - 调用方法时，stub 拦截调用方法，打包成请求信息，序列化
  - 发送给服务端
  - 服务端反序列化，得到请求参数
  - 服务存根 skeleton 去调用真正的服务，拿到结果，原路返回
- curl是什么？
- 客户端与服务端如何实现rpc?
  - 共享服务本身的方法参数和返回值
  - 类的信息
  - 接口契约
- rest 是什么？
- wsdl/wadl/idl 是什么？
- 如何理解消费？
- 代理是什么？
  - 动态代理技术是什么？
- 动态方法和属性是什么？
- 序列化和反序列化的作用是什么？
- 序列化和反序列化的几种方式有什么区别？
  - 语言原生序列化
  - 二进制平台无关
  - 文本
- 网路传输
  - tcp与http 有什么区别？
  - ssl/tls 与tcp, http与https 的关系是什么？
  - tcp性能为何更好？
- 查找实现类需要什么技术?
  - 注册方式的实现原理是什么？
- rpc 常见技术框架有哪些？
  - java rmi
  - .net remoting
- com技术是什么？
- ltx 技术是什么？
- com 本质论
- json-rpc,xml-rpc
- rest是什么？
- webservice 有哪些规范？
- webservce 为何不用了？
- （axis2,cxf）
- 海洋实现 webservice 用的是什么技术？
- 基于二进制的rpc框架 hessian/thrift/protocol buffer/grpc
- idl 是什么？
- Hessian 基于 http 协议，hessian 序列化
- thrift facebook 开源，二进制 tcp
- grpc google 开源



*如何设计一个rpc框架*

- 思考哪些方面？
  - 基于共享接口还是idl?
  - 基于动态代理还是aop?
  - 序列化用哪种方式，文本（json/xml）？二进制(hissen/pb)？
  - 网络用tcp还是http的？
  - 服务器端如何查找实现类？
  - 如何注册？
  - 异常如何处理？
- rpc框架
  - 异常处理：标识位
  - 共享pojo定义和接口定义
  - core 是框架核心代码
  - api 共享包的设计方式
  - 动态代理技术
    - java 动态代理
  - aop技术如何实现代理
    - 运行时生成动态实现类
  - 网络传输使用 http
  - 查找实现类：默认使用spring 的 getbean()
- 如何串代码？
  - 几个子项目
  - core 核心
  - api 核心定义请求和响应
  - 服务是如何暴露的？
- zookeper 是什么？



*rpc到分布式服务化*

- 什么是分布式服务化？
- 如何注册发现服务？
- 如何负载均衡和路由？
- 熔断和限流如何设计？
- 重试策略如何设计？
- 高可用、监控、性能如何设计？
- 微服务架构是什么样的？
- rpc增强包括哪些方面?
- 注册中心的作用是什么？
- 服务如何注册到注册中心？
- dubbo是什么？



*dubbo*

- pmc成员是什么?
- 如何学习项目源码？
- hsf 为何占据上风？
- 技术发展史
- dubbo是什么？
  - java 服务框架
  - rpc调用
  - 负载均衡
  - 服务注册发现
  - 可扩展
  - 流量调度
  - 可视化控制台
- 单元化架构是什么？
- service Mesh 是什么？
- 分层设计是什么？
- 微内核是什么？
- 插件化是什么？



*dubbo技术原理*

- 如何看框架图
- 绿色接口，蓝色类
- 横着十层
  - 每层一个rpc概念
- 左服务，右调用
- 红色线调用流程
- 细化rpc调用图
- spi 是什么？
  - service provider interface
  - 可以自己扩展实现的接口
- invoker/filter术语的区别
  - 桩 invoker
- filter 的作用是什么?
  - 做一些增强处理
- config 配置层的作用是什么？
  - 配置服务提供者，和服务消费者
- proxy 代理层， serviceProxy为中心， proxyFactory 扩展
- registry 封装服务地址的注册发现
  - url
  - registryFactory
- cluster 路由层，封装负载均衡，桥接注册中心
- 桥接是什么？
- monitor 监控层，调用统计信息
- 扩展接口是什么？
- 设计方式：一个factory，一个service，一个具体接口
- protocol rpc调用，以invocation 和result 为核心
- invocation 是什么？
- 什么样的方法需要封装？
- exchange 交换层，封装请求相应模式，同步转异步
- transport 网络传输层，抽象mina和netty 为统一接口
  - mina 是什么？
  - 数据传输接收
- serialize 数据序列化层，提供序列化编码解码工具
- 序列化消耗 cpu



*spi设计*

- 与api 的区别



今晚9:30-11:30第九周。明天上午9：00-12：00第十周。下周每天半小时，第十一周内容。下周六9：00-12：00第12周内容。下周日9：00-12：00十三章内容。下下周每天半小时十四周内容，25号完成十四周内容。26号9：00-12：00十五周内容。27号-31号每天办小时，从15章开始完成作业。1-3号每天9：-12：00，从后向前完成作业。3-号之后每天半小时继续完成作业，周末上午9：00-12：00。直到所有作业完成。



每天半小时争取在9：30-10：00期间。如超过九点下班则在通勤期间完成，简略笔记，周末誊抄。







